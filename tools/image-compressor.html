<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Image Compressor ‚Äî Toolgenix</title>
<style>
:root{
  --bg:#071025; --panel:#0e1724; --muted:#9fb0c7;
  --accentA:#7c5cff; --accentB:#39d98a;
  --glass: rgba(255,255,255,0.03);
  --radius:12px;
}
*{box-sizing:border-box}
body{
  margin:0;background:linear-gradient(180deg,var(--bg),#02101a);color:#eaf6ff;font-family:Inter,system-ui,Arial;
  -webkit-font-smoothing:antialiased;padding:18px;
}
.container{max-width:1000px;margin:0 auto}
.header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
.brand h1{margin:0;color:var(--accentB)} .brand p{margin:0;color:var(--muted);font-size:13px}

.grid{display:grid;grid-template-columns:1fr 360px;gap:14px}
@media(max-width:980px){.grid{grid-template-columns:1fr}}

.card{background:linear-gradient(180deg,rgba(255,255,255,0.01),rgba(255,255,255,0.005));padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.03)}
.uploader{display:flex;flex-direction:column;gap:10px;align-items:center;border-radius:10px;padding:18px;background:var(--panel);border:1px dashed rgba(255,255,255,0.04)}
.drop{width:100%;padding:28px;border-radius:10px;border:2px dashed rgba(255,255,255,0.03);text-align:center;cursor:pointer;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent)}
.drop.dragover{border-color:rgba(122,255,170,0.4);box-shadow:0 8px 40px rgba(0,0,0,0.6) inset}
.previewRow{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
.previewBox{flex:1;min-width:180px;background:var(--glass);padding:8px;border-radius:8px;text-align:center}
.previewBox img{max-width:100%;height:auto;border-radius:8px;display:block;margin:0 auto}
.small{font-size:13px;color:var(--muted)}
.row{display:flex;gap:8px;align-items:center}
.label{min-width:120px;color:var(--muted);font-size:13px}
.input,select{padding:8px;border-radius:8px;border:none;background:var(--glass);color:inherit}
.btn{padding:10px 12px;border-radius:10px;border:none;cursor:pointer;background:linear-gradient(90deg,var(--accentB),var(--accentA));color:#022;font-weight:800}
.btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.03);color:var(--muted)}
.note{font-size:12px;color:var(--muted);margin-top:6px}

.meta{display:flex;flex-direction:column;gap:6px;margin-top:8px}
.stat{display:flex;justify-content:space-between;align-items:center;padding:8px;background:rgba(255,255,255,0.01);border-radius:8px;font-size:14px}

.footer{margin-top:12px;color:var(--muted);font-size:13px;text-align:center}
.warn{color:#ffd08a}
</style>
</head>
<body>
<div class="container" role="main">
  <div class="header">
    <div class="brand">
      <h1>Image Compressor ‚Äî Toolgenix</h1>
      <p class="small">Reduce image file size quickly ‚Äî client-side, private, fast</p>
    </div>
    <div class="small">Supports PNG, JPG/JPEG, WEBP, GIF (static frame), BMP, TIFF</div>
  </div>

  <div class="grid" aria-live="polite">
    <!-- left -->
    <section class="card">
      <div class="uploader">
        <div id="dropZone" class="drop" tabindex="0">
          <div style="font-size:32px">üñºÔ∏è</div>
          <div style="font-weight:700;margin-top:6px">Drop image here or click to choose</div>
          <div class="small" style="margin-top:6px">PNG, JPG, JPEG, WEBP, GIF, BMP, TIFF ‚Äî max 25MB recommended</div>
          <input id="fileInput" type="file" accept="image/*" style="display:none" />
        </div>

        <div style="width:100%;display:flex;gap:8px;flex-wrap:wrap;justify-content:center">
          <button id="compressBtn" class="btn" disabled>Compress Image</button>
          <button id="resetBtn" class="btn ghost">Reset</button>
          <button id="downloadBtn" class="btn ghost" disabled>Download</button>
        </div>
        <div id="processing" class="small" style="display:none;margin-top:6px">Processing‚Ä¶</div>
      </div>

      <div style="margin-top:12px">
        <div class="row" style="align-items:center">
          <div class="label">Quality Preset</div>
          <select id="preset" class="input">
            <option value="high">High (minimal quality loss)</option>
            <option value="medium" selected>Medium (balanced)</option>
            <option value="low">Low (max compression)</option>
            <option value="custom">Custom</option>
          </select>
          <div style="flex:1"></div>
          <label class="small" title="Convert PNG/TIFF/BMP to JPEG or WebP to reduce size"><input type="checkbox" id="convertCheckbox" /> Convert to WebP/JPEG</label>
        </div>

        <div id="customControls" style="display:none;margin-top:8px">
          <div class="row"><div class="label">Output Format</div>
            <select id="format" class="input">
              <option value="original">Keep original</option>
              <option value="image/jpeg">JPEG</option>
              <option value="image/webp" selected>WebP</option>
            </select>
          </div>

          <div class="row" style="margin-top:8px">
            <div class="label">Quality (0.1 - 1.0)</div>
            <input id="qualitySlider" type="range" min="0.1" max="1" step="0.01" value="0.75" />
            <div class="small" id="qualityVal">0.75</div>
          </div>

          <div class="row" style="margin-top:8px">
            <div class="label">Resize</div>
            <select id="resizeMode" class="input">
              <option value="none" selected>Keep original</option>
              <option value="percent">Scale by %</option>
              <option value="maxwidth">Fit to max width</option>
            </select>
            <input id="resizeValue" class="input" type="number" min="10" max="4000" value="100" style="width:110px;display:none;margin-left:8px" />
            <div class="small" id="resizeNote" style="margin-left:6px">%</div>
          </div>
        </div>

        <div class="note">Tip: For best compression convert PNGs to WebP or JPEG if transparency not required. GIF animations will be flattened to first frame.</div>
      </div>

      <div style="margin-top:12px">
        <div class="small" style="font-weight:700">Preview</div>
        <div class="previewRow" style="margin-top:8px">
          <div class="previewBox">
            <div class="small" style="font-weight:700">Original</div>
            <img id="origPreview" alt="Original preview" />
            <div id="origInfo" class="small meta"></div>
          </div>
          <div class="previewBox">
            <div class="small" style="font-weight:700">Compressed</div>
            <img id="outPreview" alt="Compressed preview" />
            <div id="outInfo" class="small meta"></div>
          </div>
        </div>
      </div>

    </section>

    <!-- right sidebar -->
    <aside class="card">
      <div style="font-weight:700" class="small">Compression Details</div>
      <div class="meta" style="margin-top:8px">
        <div class="stat"><div>Original size</div><div id="origSize">‚Äî</div></div>
        <div class="stat"><div>Compressed size</div><div id="outSize">‚Äî</div></div>
        <div class="stat"><div>Saved</div><div id="saved">‚Äî</div></div>
        <div class="stat"><div>Output format</div><div id="outFormat">‚Äî</div></div>
        <div class="stat"><div>Resolution</div><div id="resolution">‚Äî</div></div>
      </div>

      <div style="margin-top:12px">
        <div class="small" style="font-weight:700">Advanced</div>
        <div style="margin-top:8px" class="small">
          <label><input type="checkbox" id="stripMetadata" checked /> Strip metadata (EXIF) for smaller files</label>
        </div>
        <div style="margin-top:8px" class="small warn" id="gifWarn" style="display:none"></div>
      </div>

      <div style="margin-top:14px">
        <div class="small" style="font-weight:700">About</div>
        <div class="small" style="margin-top:6px">Compression runs in your browser ‚Äî your images are not uploaded anywhere. For animated GIFs or multi-page TIFFs, only the first frame/page will be used.</div>
      </div>
    </aside>
  </div>

  <div class="footer">Built for Toolgenix ‚Äî Client-side, private. Want server-side batch compression? Ask me and I'll add it.</div>
</div>

<script>
// Utility
const $ = id => document.getElementById(id);
const humanFileSize = (bytes) => {
  if (bytes === 0) return '0 B';
  const i = Math.floor(Math.log(bytes) / Math.log(1024));
  const sizes = ['B','KB','MB','GB','TB'];
  return (bytes / Math.pow(1024, i)).toFixed(i ? 2 : 0) + ' ' + sizes[i];
};
const readFileAsDataURL = file => new Promise((r, rej) => {
  const fr = new FileReader();
  fr.onload = () => r(fr.result);
  fr.onerror = rej;
  fr.readAsDataURL(file);
});
const sleep = ms => new Promise(r=>setTimeout(r, ms));

// DOM
const dropZone = $('dropZone'), fileInput = $('fileInput'), compressBtn = $('compressBtn'), resetBtn = $('resetBtn'),
      downloadBtn = $('downloadBtn'), processingEl = $('processing');

const origPreview = $('origPreview'), outPreview = $('outPreview');
const origSize = $('origSize'), outSize = $('outSize'), savedEl = $('saved'), outFormatEl = $('outFormat'),
      resolutionEl = $('resolution');

const preset = $('preset'), convertCheckbox = $('convertCheckbox'), customControls = $('customControls'),
      formatSelect = $('format'), qualitySlider = $('qualitySlider'), qualityVal = $('qualityVal'),
      resizeMode = $('resizeMode'), resizeValue = $('resizeValue'), resizeNote = $('resizeNote'),
      stripMetadata = $('stripMetadata'), gifWarn = $('gifWarn');

// State
let currentFile = null;
let currentImage = null; // HTMLImageElement loaded
let origBlob = null;
let outBlob = null;
let origMime = null;
let isAnimatedGif = false;

// Preset qualities
function presetToQuality(p){
  if(p === 'high') return 0.92;
  if(p === 'medium') return 0.75;
  if(p === 'low') return 0.6;
  return parseFloat(qualitySlider.value);
}

// Events: drag & drop
dropZone.addEventListener('click', ()=> fileInput.click());
;['dragenter','dragover'].forEach(ev => dropZone.addEventListener(ev, e=>{ e.preventDefault(); dropZone.classList.add('dragover'); }));
;['dragleave','drop'].forEach(ev => dropZone.addEventListener(ev, e=>{ e.preventDefault(); dropZone.classList.remove('dragover'); }));
dropZone.addEventListener('drop', async (e)=>{
  const f = e.dataTransfer.files && e.dataTransfer.files[0];
  if(f) handleFile(f);
});
fileInput.addEventListener('change', async (e)=> {
  const f = e.target.files && e.target.files[0];
  if(f) handleFile(f);
});

// show/hide custom controls
preset.addEventListener('change', ()=> {
  customControls.style.display = preset.value === 'custom' ? 'block' : 'none';
  if(preset.value !== 'custom'){
    // map preset to quality slider
    const q = presetToQuality(preset.value);
    qualitySlider.value = q;
    qualityVal.textContent = q.toFixed(2);
  }
});
qualitySlider.addEventListener('input', ()=> qualityVal.textContent = qualitySlider.value);

// resize mode control
resizeMode.addEventListener('change', ()=> {
  if(resizeMode.value === 'percent'){
    resizeValue.style.display = 'inline-block';
    resizeNote.textContent = '%';
    resizeValue.value = 100;
  } else if(resizeMode.value === 'maxwidth'){
    resizeValue.style.display = 'inline-block';
    resizeNote.textContent = 'px max width';
    resizeValue.value = 1200;
  } else {
    resizeValue.style.display = 'none';
    resizeNote.textContent = '';
  }
});

// Reset
resetBtn.addEventListener('click', resetAll);

// Compress
compressBtn.addEventListener('click', async ()=>{
  if(!currentFile || !currentImage) return alert('Please choose an image first');
  processingStart();
  await sleep(30); // allow UI
  try{
    outBlob = await compressImage({
      file: currentFile,
      img: currentImage,
      quality: preset.value === 'custom' ? parseFloat(qualitySlider.value) : presetToQuality(preset.value),
      convert: convertCheckbox.checked,
      outFormat: formatSelect.value,
      resizeMode: resizeMode.value,
      resizeValue: parseInt(resizeValue.value,10),
      stripMetadata: stripMetadata.checked
    });
    // update preview and stats
    const outURL = URL.createObjectURL(outBlob);
    outPreview.src = outURL;
    outSize.textContent = humanFileSize(outBlob.size);
    const savedBytes = (origBlob.size - outBlob.size);
    savedEl.textContent = (savedBytes > 0) ? `${humanFileSize(savedBytes)} (${Math.round(100*(savedBytes)/origBlob.size)}% saved)` : 'No savings';
    outFormatEl.textContent = outBlob.type || '‚Äî';
    resolutionEl.textContent = `${outPreview.naturalWidth || currentImage.naturalWidth} √ó ${outPreview.naturalHeight || currentImage.naturalHeight}`;
    downloadBtn.disabled = false;
  } catch(err){
    alert('Compression failed: ' + err.message);
    console.error(err);
  } finally {
    processingEnd();
  }
});

// Download
downloadBtn.addEventListener('click', ()=>{
  if(!outBlob) return alert('No compressed image yet');
  const a = document.createElement('a');
  const ext = outBlob.type === 'image/png' ? 'png' : outBlob.type === 'image/webp' ? 'webp' : 'jpg';
  a.href = URL.createObjectURL(outBlob);
  a.download = `image-compressed.${ext}`;
  a.click();
});

// Handle selected file
async function handleFile(file){
  resetOutputPreview();
  // check size
  if(file.size > 50 * 1024 * 1024) {
    if(!confirm('File is large (>50MB). Continue?')) return;
  }
  const allowed = /^image\/(png|jpe?g|webp|gif|bmp|tiff?)$/i;
  if(!allowed.test(file.type) && !file.name.match(/\.(png|jpe?g|jpg|webp|gif|bmp|tiff?)$/i)){
    return alert('Unsupported file type. Please select an image.');
  }
  currentFile = file;
  origBlob = file;
  origMime = file.type;
  origPreview.src = '';
  outPreview.src = '';
  origSize.textContent = humanFileSize(file.size);
  outSize.textContent = '‚Äî';
  savedEl.textContent = '‚Äî';
  outFormatEl.textContent = '‚Äî';
  resolutionEl.textContent = '‚Äî';
  // load image
  const dataUrl = await readFileAsDataURL(file);
  // animated GIF detection (basic): look into file signature or use regex? We'll check file.type = image/gif and size of data URL contains "GIF89a" or "GIF87a" in header - but FileReader dataURL doesn't include header clear. Use ArrayBuffer check:
  isAnimatedGif = false;
  if(file.type === 'image/gif') {
    try {
      const arr = new Uint8Array(await file.arrayBuffer());
      // check for multiple frame signatures "NETSCAPE2.0" as simple indicator
      const text = String.fromCharCode.apply(null, arr.subarray(0, Math.min(arr.length, 2000)));
      if(/NETSCAPE2.0|NETSCAPE/gi.test(text)) isAnimatedGif = true;
    } catch(e){}
  }
  if(isAnimatedGif){
    gifWarn.textContent = 'Animated GIF detected ‚Äî only the first frame will be compressed (animation lost).';
    gifWarn.style.display = 'block';
  } else { gifWarn.style.display = 'none'; }

  // create image element and wait load
  const img = new Image();
  img.onload = () => {
    currentImage = img;
    // show original preview
    origPreview.src = dataUrl;
    origPreview.onload = () => {
      resolutionEl.textContent = `${origPreview.naturalWidth} √ó ${origPreview.naturalHeight}`;
    };
    // enable buttons
    compressBtn.disabled = false;
    resetBtn.disabled = false;
    downloadBtn.disabled = true;
  };
  img.onerror = (e) => {
    alert('Failed to decode image in browser. The file type may be unsupported.');
    console.error(e);
  };
  img.src = dataUrl;
}

// Compression pipeline
async function compressImage(opts){
  // opts: file, img, quality (0.1-1), convert (bool), outFormat (mime or 'original'), resizeMode, resizeValue, stripMetadata
  const { file, img, quality, convert, outFormat, resizeMode, resizeValue } = opts;
  // Determine output mime
  const keepOriginal = !convert && (outFormat === 'original' || !outFormat);
  let outMime = file.type;
  if(!keepOriginal){
    if(outFormat && outFormat !== 'original') outMime = outFormat;
    else outMime = 'image/webp'; // default convert target
  }

  // Choose if target supports quality param: JPEG & WebP support second param in toDataURL; PNG does not (will be lossless).
  // For PNG we can convert to JPEG/WebP for better compression unless user keeps original.
  // Prepare canvas at proper size
  let targetW = img.naturalWidth, targetH = img.naturalHeight;
  if(resizeMode === 'percent'){
    const pct = Math.max(10, Math.min(400, parseInt(resizeValue||100,10)));
    const scale = pct / 100;
    targetW = Math.max(1, Math.round(img.naturalWidth * scale));
    targetH = Math.max(1, Math.round(img.naturalHeight * scale));
  } else if(resizeMode === 'maxwidth'){
    const maxW = Math.max(50, Math.min(8000, parseInt(resizeValue||1200,10)));
    if(img.naturalWidth > maxW){
      const scale = maxW / img.naturalWidth;
      targetW = Math.round(img.naturalWidth * scale);
      targetH = Math.round(img.naturalHeight * scale);
    }
  }

  // Create canvas and draw
  const canvas = document.createElement('canvas');
  canvas.width = targetW;
  canvas.height = targetH;
  const ctx = canvas.getContext('2d');
  // high-quality resizing
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';
  ctx.clearRect(0,0,targetW,targetH);
  ctx.drawImage(img, 0,0, targetW, targetH);

  // Optionally strip metadata: draw image to canvas strips EXIF automatically.
  // Now export using desired mime & quality
  const mime = outMime;
  // for PNG output with compression user might want to keep PNG - PNG is lossless so toDataURL quality ignored
  // Use toBlob for binary
  const blob = await new Promise((resolve) => {
    // quality parameter only used for lossy formats (image/jpeg, image/webp)
    if(mime === 'image/png'){
      canvas.toBlob(resolve, mime);
    } else if(mime === 'image/jpeg' || mime === 'image/webp'){
      canvas.toBlob(resolve, mime, quality);
    } else {
      // fallback: try webp
      canvas.toBlob(resolve, 'image/webp', quality);
    }
  });

  // If user chose original format and original was PNG & quality <1, we might convert to JPEG/WebP only if convert flag set earlier.
  return blob;
}

// UI helpers
function resetOutputPreview(){
  currentFile = null; currentImage = null; origBlob = null; outBlob = null; origMime = null; isAnimatedGif = false;
  origPreview.src = ''; outPreview.src = '';
  origSize.textContent = '‚Äî'; outSize.textContent = '‚Äî'; savedEl.textContent = '‚Äî'; outFormatEl.textContent = '‚Äî'; resolutionEl.textContent = '‚Äî';
  compressBtn.disabled = true; downloadBtn.disabled = true; resetBtn.disabled = false;
  gifWarn.style.display = 'none';
}

function resetAll(){
  fileInput.value = '';
  resetOutputPreview();
  preset.value = 'medium';
  qualitySlider.value = 0.75; qualityVal.textContent = '0.75';
  formatSelect.value = 'image/webp';
  resizeMode.value = 'none';
  resizeValue.style.display = 'none';
  stripMetadata.checked = true;
}

// Processing UI
function processingStart(){
  processingEl.style.display = 'block';
  compressBtn.disabled = true;
  resetBtn.disabled = true;
  downloadBtn.disabled = true;
}
function processingEnd(){
  processingEl.style.display = 'none';
  compressBtn.disabled = false;
  resetBtn.disabled = false;
}

// Init
resetAll();

</script>
</body>
</html>
